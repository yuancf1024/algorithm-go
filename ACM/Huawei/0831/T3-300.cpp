/**
 * @file T3-300.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-09-10
 * 
 * @copyright Copyright (c) 2022
 * 
 * 第三题：高速公路休息站充电规划 （部分AC）
题目描述
张三购买了一辆续航里程数达1000公里的某自动驾驶新能源车。
某一天车辆充满电后，需从甲城出发前往距离D公里远的乙城，全程走高速。

车载导航提示沿途有N个休息站均可提供充电服务，
各休息站均可实时提供当前充电排队时间(小时)。
请协助规划时间最优的休息站充电方案，返回最短的旅行用时。

为方便计算，高速上的行驶速度固定为100公里/小时。
规划时可不必考虑保留安全续航里程数，汽车可以将电完全用光，
1000公里续航的汽车按100公里/小时，可以开10个小时。
每次充电时间固定为1小时，完成后电量充满。
各站点充电排队时间不会变化，充电排队过程不耗电。

输入描述

第一行表示甲乙两城的距离D，单位为公里;

第二行表示沿途的休息站数量N;

第三行起，每行2个数据，分别表示休息站距离甲城的距离，
以及充电排队所需时间(小时)，(各休息站按离从近到远排序)

0<=D<=1000000，D是100的整数倍

0<=N<=10000

1500
4
300 2
600 1
1000 0
1200 0

输出描述

旅程总计花费的最短时间(小时) 若无法到达终点，则返回-1

16

解释:

最佳方案：只在第3个休息站(位置1000)进行充电

1500公里的行程耗时:15小时

充电排队0小时，充电1小时

最快旅程总计花费16小时

其他方案:

在第2个休息站(位置600)进行充电，总计花费17小时

其他方案:

在第2个休息站(位置600)和第4个休息站(位置1200)进行充电，

总计花费19小时
 */

/*
思路
利用动态规划+加回退搜索

把起始点设为0，每次到达一个新的站点，便进行回退搜索，
一直搜索到1000公里以内且距离最远的充电站点k，
然后从k站点开始遍历，一直遍历到当前站点，
找到最短到达当前站点的时间，然后保存到当前站点的时间数组ans中，
不断循环遍历，最终遍历到终点。


本题代码虽然没有全部AC，但是思路非常好。
DP+回退搜索，我还从来没有训练过这种题目，很棒的一道题。

*/

// #define DEBUG 1
// #if DEBUG 

// #include <bits/stdc++.h>

// using namespace std;

// int main() {
//     int n, m;
//     cin >> n;
//     cin >> m;

//     // 初始化站点数组，将起点和终点也纳入数组中
//     vector<vector<int>> f(m + 2, vector<int>(2));

//     // 起点的距离和等待时间均为0
//     f[0][0] = 0;
//     f[0][1] = 0;
//     // 终点的距离为n，等待时间为0
//     f[m + 1][0] = n;
//     f[m + 1][1] = 0;

//     // 开始加入各个站点
//     for (int i = 1; i < m + 1; ++i) {
//         cin >> f[i][0];
//         cin >> f[i][1];
//         // cout << f[i][0] << ' ';
//         // cout << f[i][1] << ' ';
//     }

//     // 初始化到达站点的时间，将起点和终点也纳入数组中
//     vector<int> ans(m + 2);
//     ans[0] = 0;

//     // 开始计算各个站点
//     for (int i = 1; i < m + 2; ++i) {
//         // 将所有距离在1000以内的站点找出来
//         int k = i - 1;
//         while (k > 0 && (f[i][0] - f[k][0] < 1000)) {
//             k--;
//         }

//         // 这段代码是否需要存疑？？？
//         // 这里除了起始站点外，多超了一个站点，因此k需要加1
//         // if (k != 0) {
//         //     k++;
//         // }

//         // 对每个可以直接到达的站点进行遍历，找出最小的时间站点
//         int min_time = INT_MAX;
//         for (; k < i; ++k) {
//             int cur_time = (f[i][0] - f[k][0]) / 100 + ans[k] + f[i][1]; // 到达前所花时间+距离花费时间+排队时间
//             if (k != 0) { // ?
//                 cur_time++; // 充电时间
//             }
//             min_time = min(min_time, cur_time); 
//         }
//         ans[i] = min_time; 
//     }

//     cout << ans[m + 1] << endl;
//     return 0;
// }

// #endif

/*
Q群大佬的解法
思路：
直接DP的思路更好理解，要求最短旅行用时，本题的关键是合理安排站点，
最短用时由三部分组成，距离用时+排队用时+充电用时，
实际上推到dp公式时只需要考虑排队用时即可。

本题的DP存在部分枚举遍历，有超时的风险，
引入贪心就肯定可以AC

*/

#include <bits/stdc++.h>

using namespace std;

int main() { 
    int d, n;

    cin >> d >> n;

    vector<vector<int>> station(n + 2, vector<int>(2));
    station[0][0] = 0;
    station[0][1] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> station[i][0];
        cin >> station[i][1];
    }

    station[n + 1][0] = d;
    station[n + 1][1] = 0;
    // 打印
    // for (int i = 0; i < station.size(); ++i) {
    //     cout << station[i][0] << " " << station[i][1] << endl;
    // }

    int res = d / 100;

    vector<int> dp(n + 2, 0);
    dp[0] = 0;
    for (int i = 1; i < n+2; ++i) {
        dp[i] = dp[i - 1] + station[i][1];
    }
    for (int i = 1; i < n + 2; ++i) {
        if ((station[i][0] - station[i-1][0]) > 1000) {
            cout << -1 << endl;
            return 0;
        }
        for (int j = i - 1; j >= 0; --j) {
            if (station[i][0] - station[j][0] <= 1000) {
                dp[i] = min(dp[i], dp[j] + station[i][1]); // 排队时间，选取耗时最少的站点
            }
            if (i != n+1) {
                dp[i] += 1; // 充电时间
            }
        } 
    }
    // 打印dp
    for (auto& x : dp) {
        cout << x << " ";
    }
    res += dp[n + 1];
    cout << res << endl;
    return 0;
}