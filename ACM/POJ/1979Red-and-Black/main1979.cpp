/* POJ 1979 Red and Black （红与黑）
https://www.cnblogs.com/simon-x/p/5851280.html

题目描述
有个铺满方形瓷砖的矩形房间，每块瓷砖的颜色非红即黑。
某人在一块砖上，他可以移动到相邻的四块砖上。
但他只能走黑砖，不能走红砖。

敲个程序统计一下这样可以走到几块红砖上。

输入
多组测试用例。每组数组开头有两个正整数W和H；
W与H分别表示 x- 与 y- 方向上瓷砖的数量。W和H均不超过20。
还有H行数据，每行包含W个字符。每个字符表示各色瓷砖如下。
‘.’- 一块黑砖
‘#’- 一块红砖
‘@’- 一个黑砖上的人（一组数据一个人）

输入以一行两个零为结束。

输出
对于每组测试用例，输出他从起始砖出发所能抵达的瓷砖数量（包括起始砖）。

Sample Input - 输入样例
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0

Sample Output - 输出样例
45
59
6
13

【题解】
数据不大，DFS可解。
*/ 

#include <cstdio>
#include <cstring>
char data[25][25];
int sum;
void DFS(int y, int x) {
    if (data[y][x] == '#') return;
    ++sum;
    data[y][x] = '#';
    DFS(y+1, x);
    DFS(y-1, x);
    DFS(y, x+1);
    DFS(y, x-1);
}

int main() {
    int w, h, i, j, stY, stX;
    while (~scanf("%d%d", &w, &h)) {
        if ()
    }
}
