// 汉诺塔问题可以描述为：

// 有三根杆(编号 A、B、C)，在 A 杆自下而上、由大到小按顺序放置 64 个金盘
// 。游戏的目标：把 A 杆上的金盘全部移到 C 杆上，并仍保持原有顺序叠好。

// 操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上
// 都始终保持大盘在下，小盘在上，操作过程中盘子可以置于 A、B、C 任一杆上。

// 我们很自然想到一个算法：

// 我们必须先借助 C 杆，将 A 杆前面 N-1 个盘子，移动到 B 杆后，
// 将 A 杆剩下的一个盘子，直接移动到 C 杆，这时候 A 空了。
// 然后借助 A 杆，将 B 杆的 N-1 个盘子，移动到 C 杆，任务就完成了。
// 十分朴素的思路，我们用编程语言来实现：

package main

import "fmt"

var total = 0

// 汉诺塔
// 一开始A杆上有N个盘子,B和C杆都没有盘子.
func main() {
	n := 4 // 64个盘子
	a := "a" // 杆子A
	b := "b" // 杆子B
	c := "c" // 杆子C
	tower(n, a, b, c)

	// 当 n=1 时，移动次数为 1
    // 当 n=2 时，移动次数为 3
    // 当 n=3 时，移动次数为 7
    // 当 n=4 时，移动次数为 15
	fmt.Println(total)
}

// 表示将N个盘子,从a杆,借助b杆移到c杆
func tower(n int, a, b ,c string) {
	if n == 1 {
		total = total + 1
		fmt.Println(a, "->", c)
		return
	}
	tower(n-1, a, c, b)
	total = total + 1
	fmt.Println(a, "->", c)
	tower(n-1, b, a, c)
}