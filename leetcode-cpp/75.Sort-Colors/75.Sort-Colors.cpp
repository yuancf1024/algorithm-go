/**
 * @file 75.Sort-Colors.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2022-08-16
 * 
 * @copyright Copyright (c) 2022
 * leetcode-75.颜色分类
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，
原地对它们进行排序，使得相同颜色的元素相邻，
并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。

示例 1：
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

示例 2：
输入：nums = [2,0,1]
输出：[0,1,2]
 
提示：
n == nums.length
1 <= n <= 300
nums[i] 为 0、1 或 2
 
进阶：

你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？

 */

// 方法一：单指针
class Solution {
public:
    void sortColors(vector<int>& nums) { 
        int n = nums.size();
        int ptr = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 0) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
        for (int i = ptr; i < n; ++i) {
            if (nums[i] == 1) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
    }
};

// 方法2：双指针
class Solution {
public:
    void sortColors(vector<int>& nums) { 
        int n = nums.size();
        int p0 = 0, p1 = 0;
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) {
                swap(nums[i], nums[p1]);
                ++p1;
            } else if (nums[i] == 0) {
                swap(nums[i], nums[p0]);
                if (p0 < p1) {
                    swap(nums[i], nums[p1]); // 注意如果 p0 <p1，那么我们需要再将 nums[i] 与 nums[p1] 进行交换
                }
                ++p0;
                ++p1;
            }
        }
    }
};

/**
 * @brief 
 * 前言
本题是经典的「荷兰国旗问题」，由计算机科学家 Edsger W. Dijkstra 首先提出。

根据题目中的提示，我们可以统计出数组中0,1,2 的个数，
再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，
而本题解中会介绍两种基于指针进行交换的方法。

方法一：单指针
思路与算法

我们可以考虑对数组进行两次遍历。在第一次遍历中，
我们将数组中所有的0 交换到数组的头部。
在第二次遍历中，我们将数组中所有的1 交换到头部的0 之后。
此时，所有的2 都出现在数组的尾部，这样我们就完成了排序。

具体地，我们使用一个指针ptr 表示「头部」的范围，ptr 中存储了一个整数，
表示数组nums 从位置0 到位置ptr−1 都属于「头部」。ptr 的初始值为0，
表示还没有数处于「头部」。

在第一次遍历中，我们从左向右遍历整个数组，如果找到了0，那么就需要将0 
与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。
在遍历结束之后，所有的0 都被交换到「头部」的范围，并且「头部」只包含0。

在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了1，
那么就需要将1 与「头部」位置的元素进行交换，
并将「头部」向后扩充一个位置。在遍历结束之后，
所有的 1 都被交换到「头部」的范围，并且都在 0 之后，
此时2 只出现在「头部」之外的位置，因此排序完成。


复杂度分析
时间复杂度：O(n)，其中n 是数组nums 的长度。
空间复杂度：O(1)。



方法二：双指针
思路与算法

方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？
我们可以额外使用一个指针，即使用两个指针分别用来交换0 和1。
具体地，我们用指针p0来交换0，p1来交换1，初始值都为0。
当我们从左向右遍历整个数组时：

如果找到了1，那么将其与nums[p1] 进行交换，并将p1向后移动一个位置，
这与方法一是相同的；

如果找到了0，那么将其与 nums[p0] 进行交换，并将p0向后移动一个位置。
这样做是正确的吗？我们可以注意到，因为连续的0 之后是连续的1，
因此如果我们将 0 与 nums[p0] 进行交换，那么我们可能会把一个1 交换出去。
当p0 <p1时，我们已经将一些1 连续地放在头部，此时一定会把一个1 交换出去，
导致答案错误。
因此，如果 p0 <p1，那么我们需要再将 nums[i] 与 nums[p1] 进行交换，
其中i 是当前遍历到的位置，在进行了第一次交换后，nums[i] 的值为1，
我们需要将这个1 放到「头部」的末端。
在最后，无论是否有 p0 < p1，我们需要将 p0和 p1均向后移动一个位置，
而不是仅将 p0向后移动一个位置。

复杂度分析

时间复杂度：O(n)，其中 n 是数组nums 的长度。
空间复杂度：O(1)。

方法三：双指针
思路与算法

与方法二类似，我们也可以考虑使用指针 p_0p 
0
​
  来交换 00，p_2p 
2
​
  来交换 22。此时，p_0p 
0
​
  的初始值仍然为 00，而 p_2p 
2
​
  的初始值为 n-1n−1。在遍历的过程中，我们需要找出所有的 00 交换至数组的头部，并且找出所有的 22 交换至数组的尾部。

由于此时其中一个指针 p_2p 
2
​
  是从右向左移动的，因此当我们在从左向右遍历整个数组时，如果遍历到的位置超过了 p_2p 
2
​
 ，那么就可以直接停止遍历了。

具体地，我们从左向右遍历整个数组，设当前遍历到的位置为 ii，对应的元素为 \textit{nums}[i]nums[i]；

如果找到了 00，那么与前面两种方法类似，将其与 \textit{nums}[p_0]nums[p 
0
​
 ] 进行交换，并将 p_0p 
0
​
  向后移动一个位置；

如果找到了 22，那么将其与 \textit{nums}[p_2]nums[p 
2
​
 ] 进行交换，并将 p_2p 
2
​
  向前移动一个位置。

这样做是正确的吗？可以发现，对于第二种情况，当我们将 \textit{nums}[i]nums[i] 与 \textit{nums}[p_2]nums[p 
2
​
 ] 进行交换之后，新的 \textit{nums}[i]nums[i] 可能仍然是 22，也可能是 00。然而此时我们已经结束了交换，开始遍历下一个元素 \textit{nums}[i+1]nums[i+1]，不会再考虑 \textit{nums}[i]nums[i] 了，这样我们就会得到错误的答案。

因此，当我们找到 22 时，我们需要不断地将其与 \textit{nums}[p_2]nums[p 
2
​
 ] 进行交换，直到新的 \textit{nums}[i]nums[i] 不为 22。此时，如果 \textit{nums}[i]nums[i] 为 00，那么对应着第一种情况；如果 \textit{nums}[i]nums[i] 为 11，那么就不需要进行任何后续的操作。

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。

空间复杂度：O(1)O(1)。
 */