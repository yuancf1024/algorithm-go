/**
 * @file 860.Lemonade-Change.cpp
 * @author your name (you@domain.com)
 * @brief 860. 柠檬水找零
 * @version 0.1
 * @date 2023-07-22
 * 
 * @copyright Copyright (c) 2023
 * 
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。
顾客排队购买你的产品，（按账单 bills 支付的顺序）
一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元
或 20 美元。你必须给每个顾客正确找零，
也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是
第 i 位顾客付的账。如果你能给每位顾客正确找零，
返回 true ，否则返回 false 。

示例 1：
输入：bills = [5,5,5,10,20]
输出：true

解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，
并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票
和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

示例 2：

输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，
然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，
因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，
所以答案是 false。
 

提示：
1 <= bills.length <= 10^5
bills[i] 不是 5 就是 10 或是 20 
 */

#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0;
        // 遍历bills数组，排除掉所有无法找零的场景，
        // 那么最后就是都可以正常找零
        for (auto& bill : bills) {
            if (bill == 5) {
                five++;
            } else if (bill == 10) {
                if (five == 0) {
                    return false;
                }
                five--;
                ten++;
            } else {
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    } 
};

int main() {
    vector<int> bills = {5, 5, 5, 10, 20};
    bool res = Solution().lemonadeChange(bills);

    cout << res << endl;

    return 0;
}

/**
 * @brief leetcode官方解答
 * 方法一：贪心
由于顾客只可能给你三个面值的钞票，而且我们一开始
没有任何钞票，因此我们拥有的钞票面值只可能是 
5美元，10美元和20美元三种。基于此，
我们可以进行如下的分类讨论。

- 5美元，由于柠檬水的价格也为5美元，
因此我们直接收下即可。

- 10美元，我们需要找回 5美元，如果没有5美元面值
的钞票，则无法正确找零。

- 20美元，我们需要找回15美元，此时有两种组合方式，
一种是一张10美元和5美元的钞票，一种是3张5美元的
钞票，如果两种组合方式都没有，则无法正确找零。
当可以正确找零时，两种找零的方式中我们更倾向于
第一种，即如果存在5美元和10美元，我们就按第一种
方式找零，否则按第二种方式找零，因为需要使用5美元
的找零场景会比需要使用10美元的找零场景多，
我们需要尽可能保留5美元的钞票。

基于此，我们维护两个变量five和ten表示当前手中拥有
的5美元和10美元钞票的张数，从前往后遍历数组
分类讨论即可。

复杂度分析

时间复杂度：O(N)，其中N是bills的长度。

空间复杂度：O(1)。
 */