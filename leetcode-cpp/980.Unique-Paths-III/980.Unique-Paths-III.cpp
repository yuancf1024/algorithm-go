/**
 * @file 980.Unique-Paths-III.cpp
 * @author your name (you@domain.com)
 * @brief 980.不同路径 III
 * @version 0.1
 * @date 2023-08-04
 * 
 * @copyright Copyright (c) 2023
 * 
在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，
从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复
通过同一个方格。

示例 1：
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),
(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),
(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

示例 2：
输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),
(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),
(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),
(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),
(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

示例 3：
输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。

提示：

1 <= grid.length * grid[0].length <= 20
 */

#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
    int uniquePathsIII(vector<vector<int> > &grid) {
        int r = grid.size(), c = grid[0].size();
        int si = 0, sj = 0, n = 0;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid[i][j] == 0) {
                    n++;
                } else if (grid[i][j] == 1) {
                    n++;
                    si = i;
                    sj = j;
                }
            }
        }
        function <int(int, int, int)> dfs = [&](int i, int j, int n) -> int {
            if (grid[i][j] == 2) {
                if (n == 0) {
                    return 1;
                }
                return 0;
            }

            int t = grid[i][j], res = 0;
            grid[i][j] = -1;
            vector<array<int, 2>> dir({{-1, 0}, {1, 0}, {0, -1}, {0, 1}});
            for (auto &[di, dj] : dir) {
                int ni = i + di;
                int nj = j + dj;
                if (ni >= 0 && ni < r && nj >= 0 && nj < c && \
                    (grid[ni][nj] == 0 || grid[ni][nj] == 2)) {
                        res += dfs(ni, nj, n - 1);
                }
            }
            grid[i][j] = t;
            return res;
        };
        return dfs(si, sj, n);
    }
};

int main() {
    vector<vector<int> > grid = {{1,0,0,0},{0,0,0,0},{0,0,2,-1}};
    int ans = Solution().uniquePathsIII(grid);
    cout << ans << endl;

    return 0;
}

/**
 * @brief leetcode官方题解
 * 方法一：回溯
思路

按照要求，假设矩阵中有 n个 0，那么一条合格的路径，
是长度为 (n+1)，由 1 起始，结束于2，不经过 −1，
且每个点只经过一次的路径。要求出所有的合格的路径，
可以采用回溯法，定义函数 dfs，表示当前 grid 状态下，
从点 (i,j)出发，还要经过 n 个点，走到终点的路径条数。
到达一个点时，

- 如果当前的点为终点，且已经经过了 (n+1)
个点，那么就构成了一条合格的路径，否则就不构成。

- 如果当前的点不为终点，则将当前的点标记为 −1，
表示这条路径以后不能再经过这个点，然后继续在这个点
往四个方向扩展，如果不超过边界且下一个点的值为0 或者2，
则表示这条路径可以继续扩展。探测完四个方向后，
需要将当前的点的值改为原来的值。
将四个方向的合格路径求和，即为当前状态下合格路径的条数。

最终需要返回的是，grid在初始状态下，从起点出发，
需要经过 (n+1) 个点的路径条数。
复杂度分析

时间复杂度：O(4^r×c)，其中 r 和 c 分别是 grid的行数和列数。

空间复杂度：O(r×c)，是回溯的深度。

方法二：记忆化搜索+状态压缩


 */