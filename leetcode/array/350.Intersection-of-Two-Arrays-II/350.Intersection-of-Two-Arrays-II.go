package leetcode

import "sort"

/*
给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。
返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致
（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
*/

// 方法1：哈希表
func intersect(nums1 []int, nums2 []int) []int {

	// 降低空间复杂度的措施: 先遍历较短的数组
	if len(nums1) > len(nums2) {
		return intersect(nums2, nums1)
	}

	res := make([]int, 0)
	m := make(map[int]int, len(nums1))

	for _, v := range nums1 {
		m[v]++
	}

	for _, i := range nums2 {
		if m[i] > 0 {
			res = append(res, i)
			m[i]--
		}
	}
	return res
}

/* Solution：使用map
这一题还是延续第 349 题的思路。把数组一中的数字都放进字典中，
另外字典的 key 是数组中的数字，value 是这个数字出现的次数。
在扫描数组二的时候，每取出一个存在的数字，把字典中的 value 减一，
把数字添加进返回的数组中。
如果 value 是 0 代表不存在这个数字。

复杂度分析：
- 时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。
需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是 O(1)，
因此总时间复杂度与两个数组的长度和呈线性关系。
- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。
对较短的数组进行哈希表的操作，哈希表的大小不会超过较短的数组的长度。
为返回值创建一个数组 intersection，其长度为较短的数组的长度。
*/

// 方法2：排序+双指针
func intersect1(nums1 []int, nums2 []int) []int {
	sort.Ints(nums1)
	sort.Ints(nums2)

	l1, l2 := len(nums1), len(nums2)
	p1, p2 := 0, 0

	res := []int{}
	for p1 < l1 && p2 < l2 {
		if nums1[p1] < nums2[p2] {
			p1++
		} else if nums1[p1] > nums2[p2] {
			p2++
		} else {
			res = append(res, nums1[p1])
			p1++
			p2++
		}
	}
	return res
}

/* Solution:
如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。
首先对两个数组进行排序，然后使用两个指针遍历两个数组。
初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，
如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，
将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。

复杂度分析
- 时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。
对两个数组进行排序的时间复杂度是 (mlogm+nlogn)，
遍历两个数组的时间复杂度是 O(m+n)，
因此总时间复杂度是 (mlogm+nlogn)。
- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。
为返回值创建一个数组 intersection，其长度为较短的数组的长度。
不过在 C++ 中，我们可以直接创建一个 vector，不需要把答案临时存放在一个额外的数组中，
所以这种实现的空间复杂度为 O(1)。
*/

/*
进阶：

1. 如果给定的数组已经排好序呢？你将如何优化你的算法？
2. 如果 nums1 的大小比 nums2 小，哪种方法更优？
3. 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

Answer1: 使用方法2：双指针+排序

Answer2: 哈希计数
将较小的数组哈希计数，随后在另一个数组中根据哈希来寻找。
时间复杂度：O(max(n,m))
空间复杂度：O(min(n,m))

适用于进阶问题二

Answer3:
如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中。
那么就无法高效地对 nums2 进行排序，因此推荐使用方法一而不是方法二。
在方法一中，nums2只关系到查询操作，因此每次读取nums2中的一部分数据，并进行处理即可。

对应进阶问题三，如果内存十分小，不足以将数组全部载入内存，那么必然也不能使用哈希这类费空间的算法，
只能选用空间复杂度最小的算法，即解法一。

但是解法一中需要改造，一般说排序算法都是针对于内部排序，一旦涉及到跟磁盘打交道（外部排序），
则需要特殊的考虑。归并排序是天然适合外部排序的算法，可以将分割后的子数组写到单个文件中，
归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，
即可使用双指针遍历两个文件，如此可以使空间复杂度最低。
*/