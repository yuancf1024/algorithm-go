/* 7-8 521序列
所谓“521 序列”是指将一个原始整数序列 S 中的每个数字分别
乘以 5、2、1 后形成的序列，例如 S= { 5, 2, 1 } 时，
其对应的 521 序列就是 { 25, 10, 5, 10, 4, 2, 5, 2, 1 } —— 
这里我们不要求这个序列一定具有某种顺序，
即 521 序列中元素的顺序是可以打乱的。
给定 S 后，计算其对应的 521 序列是很简单的。
但给定一个 521 序列，恢复其对应的原始序列 S 就略微复杂一点了。
本题就请你恢复任意给定的 521 序列的原始序列。

输入格式：
输入第一行给出正整数 N（<10^5），为 521 序列的长度。
随后一行给出 N 个整数，即给定的 521 序列。所有数字的绝对值不超过 10^5，
以空格分隔。

输出格式：
在一行中按照非递增序输出 521 序列对应的原始序列。数字间以 1 个空格分隔，
行首尾不得有多余空格。

题目保证原始序列是存在的。

输入样例：
12
1 -5 10 -1 2 4 5 -2 5 25 10 2
输出样例：
5 2 1 -1

*/

/* 题目分析/解题思路

本题有一定难度，我们首先使用样例来分析题目。

对于样例中给出的原始序列 {5, 2, 1, -1} 我们将其变为 521 序列。
{25, 10, 5, -5, 10, 4, 2, -2, 5, 2, 1, -1}

我们将这个 521 序列分为三部分来看：{25,10,5,-5}以及{10,4,2,-2} 和{5,2,1,-1}。
如果给定我们一个521序列，我们可以比较容易地找到最大的那个数字，然后将它除以5就可以得到原始序列中的最大的那个数，
同样的我们可以用类似的方法找到次大的数，最后还原整个原始序列。

那么首先我们将给定521序列从大到小排序，然后将所有的数字插入到集合中，我们执行以下算法即可还原原始序列：

1. 从大到小遍历序列，处理元素x将其除以 5 得到原始序列中的数字，然后再在集合中删除  5x,2x,x。

2. 上述操作在遇到x(<0)时，我们便不需要将其除以5，直接删除5x,2x,x即可。

3. 持续执行以上操作直到遍历完整个521序列。

对于以上的集合以及从大到小排序，我们即可以使用“二叉搜索树”来实现，也可以直接对521序列排序，然后使用“哈希表”来充当容器。
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int n;
    cin >> n;
    multiset<int> st;
    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        st.insert(x);
    }
    n /= 3;
    for (int i = 0; i < n; ++i) {
        // int x = *rbegin(st); // C++高级特性
        int x = *begin(st);
        if (x > 0)
            x /= 5;
        st.erase(st.find(x * 5));
        st.erase(st.find(x * 2));
        st.erase(st.find(x * 1));
        cout << x << (i + 1 < n ? ' ' : '\n');
    }
    return 0;
}