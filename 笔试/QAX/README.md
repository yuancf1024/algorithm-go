# 2022-08-25奇安信笔试复盘

## 笔试细节
- 20道单选+10道不定项
- 2道编程题。

选择题基本上看缘分了，比较基础和细节，考察计网、操作系统、Linux细节、C++内存对齐、STL等基础知识。

> 平时的复习需要更加细心，争取把基础题的得分给拿到手。

编程题AC了1道，暴力搜索+依题意模拟。

事后根据群友的反馈，好像是leetcode原题改编的。分别是lc797所有可能的路径、lc11盛最多水的容器。

### T1: 考察图的路径，DFS。
大意：一个有向无环图，找出城市0到城市4(其实是n)的所有路径数。

```cpp
// 方法一：深度优先搜索 + 回溯
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> stk;

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        stk.push_back(0);
        dfs(graph, 0, graph.size() - 1);
        return ans;
    }

    // 辅函数
    void dfs(vector<vector<int>>& graph, int x, int n) { // 当前访问的节点
        if (x == n) { // 递归终止条件
            ans.push_back(stk); // 可达路径入栈
            return;
        }
        for (auto& y : graph[x]) { // 遍历当前访问节点的相邻节点
            stk.push_back(y); // 入栈
            dfs(graph, y, n); // DFS
            stk.pop_back(); // 回溯
        }
    }
};

/**
 * @brief 
 * 方法一：深度优先搜索
 * 思路和算法

我们可以使用深度优先搜索的方式求出所有可能的路径。
具体地，我们从 0 号点出发，使用栈记录路径上的点。
每次我们遍历到点 n−1，就将栈中记录的路径加入到答案中。

特别地，因为本题中的图为有向无环图（DAG），
搜索过程中不会反复遍历同一个点，因此我们无需判断当前点是否遍历过。

复杂度分析
- 时间复杂度：O(n*2^n)，其中 n 为图中点的数量。我们可以找到一种最坏情况，
即每一个点都可以去往编号比它大的点。此时路径数为 O(2^n)，
且每条路径长度为 O(n)，因此总时间复杂度为 O(n*2^n)。
- 空间复杂度：O(n)，其中 n 为点的数量。
主要为栈空间的开销。注意返回值不计入空间复杂度。
 * 
 */
```

> 这一题之前我在剑指offer上面其实是做过的，主要就是深度优先搜索和回溯。但是因为近期我做过课程表(lc210)的题，然后觉得思路应该也是差不多。于是我就在这一题的基础上改编。
> 但是实际上本题已经明确说是有向**无环**图，因此不会重复遍历某一个节点，无需额外记录每个节点是否需要访问。
> 我写的代码里面主要是辅函数dfs没有写好，回溯的细节还是没有完全掌握，递归函数的参数没有设置对，递归函数的返回条件也没有处理好，单层递归中的出栈入栈操作也没有。
> 我最开始觉得肯定是要把每条路径都记录下来的，但是我还是选择了走小路，只单纯记录路径数，其实这样处理反而麻烦了。

### T2：考察数组，双指针，特殊输入的处理。

大意：类似于lc11盛最多水的容器。
> 给定一个长度为 n 的整数数组 height 。
> 有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> 返回容器可以储存的最大水量。

**思路**

定义左右指针，分别是数组第一个元素和最后一个元素的索引，
while循环下计算此时所要求的雨水容量，
area = min(height[l], height[r]) * (r - l); // 水量计算公式
计算水量后更新最大水量ans；
然后移动左右侧高度较低的指针，继续计算雨水量。

```cpp
// 方法一：双指针
class Solution {
public:
    int maxArea(vector<int>& height) { 
        int l = 0, r = height.size() - 1; // 在初始时，左右指针分别指向数组的左右两端
        int ans = 0;
        while (l < r) {
            int area = min(height[l], height[r]) * (r - l); // 水量计算公式
            ans = max(ans, area); // 更新max
            if (height[l] <= height[r]) {
                ++l; // 因为装水取决于低的那一侧的高度，因此更新时需要移动低侧的下标
            } else {
                --r;
            }
        }
        return ans;
    }
};
```

## 总结

递归和回溯还需要加强，leetcode的复习进度需要加快，不一定需要做更多新颖的题目，把之前做过的**剑指offer+leetcodeHot100**全部都扎扎实实弄懂，应付笔试肯定是足够了的。